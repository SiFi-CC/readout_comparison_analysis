/**
 * klaus6b_channel_mapping.C: ROOT Macro for finding correlated channels based on a visual inspection on a 2d histogram
 * 
 * This macro reads the TTree generated by the Klaus6b acquisition software.
 * 
 * usage: root -l -e ".L libDAQ_client.so" klaus6b_channel_mapping.C
 *
 */
void klaus6b_channel_mapping(std::string filename="LYSO.root") {
	TFile *f = new TFile(filename.c_str(), "READ");
	TTree *t = (TTree *)f->Get("aqu_dump");
	klaus_acquisition* curr_aqu=NULL;
	t->SetBranchAddress("acquisitions", &curr_aqu);
	TH2I *hCoincCh = new TH2I("hCoincCh", ";Ch;Ch", 18, 18, 36, 18, 18, 36);
	long prevTime = 0;
	for(int i=0; i < t->GetEntries(); ++i) {
		t->GetEntry(i);
		std::map<unsigned char, std::list<klaus_event> > data = curr_aqu->data;
		for(std::map<unsigned char, std::list<klaus_event> >::iterator it = data.begin(); it != data.end(); it++) {
			std::list<klaus_event> events = it->second;
			std::vector<int> vecCh;
			for(std::list<klaus_event>::iterator it2 = events.begin(); it2 != events.end(); it2++) {
				klaus_event evt = *it2;
				vecCh.push_back(evt.channel);
			}
			for(int i=0; i < vecCh.size(); ++i) {
				for(int j=0; j < vecCh.size(); ++j) {
					if(vecCh[i] == vecCh[j]) continue;
					hCoincCh->Fill(vecCh[i], vecCh[j]);
				}
			}
		}
	}
	TCanvas *d = new TCanvas("d", "d", 500, 500);
	hCoincCh->Draw("COLZ");
	d->Draw();
}
